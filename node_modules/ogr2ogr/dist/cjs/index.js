"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const archiver_1 = __importDefault(require("archiver"));
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const os_1 = require("os");
const path_1 = require("path");
const stream_1 = require("stream");
// Known /vsistdout/ support.
const stdoutRe = /csv|geojson|georss|gml|gmt|gpx|jml|kml|mapml|pdf|vdv/i;
const vsiStdIn = "/vsistdin/";
const vsiStdOut = "/vsistdout/";
let uniq = Date.now();
class Ogr2ogr {
    constructor(input, opts = {}) {
        this.inputPath = vsiStdIn;
        this.outputFormat = opts.format ?? "GeoJSON";
        this.customCommand = opts.command;
        this.customOptions = opts.options;
        this.customDestination = opts.destination;
        this.customEnv = opts.env;
        this.timeout = opts.timeout ?? 0;
        this.maxBuffer = opts.maxBuffer ?? 1024 * 1024 * 50;
        let { path, ext } = this.newOutputPath(this.outputFormat);
        this.outputPath = path;
        this.outputExt = ext;
        if (input instanceof stream_1.Readable) {
            this.inputStream = input;
        }
        else if (typeof input === "string") {
            this.inputPath = this.newInputPath(input);
        }
        else {
            this.inputStream = stream_1.Readable.from([JSON.stringify(input)]);
        }
    }
    exec(cb) {
        this.run()
            .then((res) => cb(null, res))
            .catch((err) => cb(err));
    }
    then(onfulfilled, onrejected) {
        return this.run().then(onfulfilled, onrejected);
    }
    newInputPath(p) {
        let path = "";
        let ext = (0, path_1.extname)(p);
        switch (ext) {
            case ".zip":
            case ".kmz":
            case ".shz":
                path = "/vsizip/";
                break;
            case ".gz":
                path = "/vsigzip/";
                break;
            case ".tar":
                path = "/vsitar/";
                break;
        }
        if (/^(http|ftp)/.test(p)) {
            path += "/vsicurl/" + p;
            return path;
        }
        path += p;
        return path;
    }
    newOutputPath(f) {
        let ext = "." + f.toLowerCase();
        if (stdoutRe.test(this.outputFormat)) {
            return { path: vsiStdOut, ext };
        }
        let path = (0, path_1.join)((0, os_1.tmpdir)(), "/ogr_" + uniq++);
        switch (f.toLowerCase()) {
            case "esri shapefile":
                path += ".shz";
                ext = ".shz";
                break;
            case "mapinfo file":
            case "flatgeobuf":
                ext = ".zip";
                break;
            default:
                path += ext;
        }
        return { path, ext };
    }
    createZipStream(p) {
        let archive = (0, archiver_1.default)("zip");
        archive.directory(p, false);
        archive.on("error", console.error);
        archive.finalize();
        return archive;
    }
    async run() {
        let command = this.customCommand ?? "ogr2ogr";
        let args = [
            "-f",
            this.outputFormat,
            "-skipfailures",
            this.customDestination || this.outputPath,
            this.inputPath,
        ];
        if (this.customOptions)
            args.push(...this.customOptions);
        let env = this.customEnv ? { ...process.env, ...this.customEnv } : undefined;
        let { stdout, stderr } = await new Promise((res, rej) => {
            let proc = (0, child_process_1.execFile)(command, args, { env, timeout: this.timeout, maxBuffer: this.maxBuffer }, (err, stdout, stderr) => {
                if (err)
                    rej(err);
                res({ stdout, stderr });
            });
            if (this.inputStream && proc.stdin)
                this.inputStream.pipe(proc.stdin);
        });
        let res = {
            cmd: command + args.join(" "),
            text: stdout,
            details: stderr,
            extname: this.outputExt,
        };
        if (/^geojson$/i.test(this.outputFormat)) {
            try {
                res.data = JSON.parse(stdout);
            }
            catch (err) {
                // ignore error
            }
        }
        if (!this.customDestination && this.outputPath !== vsiStdOut) {
            if (this.outputExt === ".zip") {
                res.stream = this.createZipStream(this.outputPath);
            }
            else {
                res.stream = (0, fs_1.createReadStream)(this.outputPath);
            }
        }
        return res;
    }
}
function ogr2ogr(input, opts) {
    return new Ogr2ogr(input, opts);
}
exports.default = ogr2ogr;
